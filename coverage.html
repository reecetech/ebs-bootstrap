
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>action: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/reecetech/ebs-bootstrap/internal/action/action.go (89.3%)</option>
				
				<option value="file1">github.com/reecetech/ebs-bootstrap/internal/action/file.go (0.0%)</option>
				
				<option value="file2">github.com/reecetech/ebs-bootstrap/internal/action/format.go (0.0%)</option>
				
				<option value="file3">github.com/reecetech/ebs-bootstrap/internal/action/label.go (0.0%)</option>
				
				<option value="file4">github.com/reecetech/ebs-bootstrap/internal/action/mount.go (0.0%)</option>
				
				<option value="file5">github.com/reecetech/ebs-bootstrap/internal/action/resize.go (0.0%)</option>
				
				<option value="file6">github.com/reecetech/ebs-bootstrap/internal/config/config.go (100.0%)</option>
				
				<option value="file7">github.com/reecetech/ebs-bootstrap/internal/config/modifier.go (100.0%)</option>
				
				<option value="file8">github.com/reecetech/ebs-bootstrap/internal/config/validator.go (100.0%)</option>
				
				<option value="file9">github.com/reecetech/ebs-bootstrap/internal/model/action.go (100.0%)</option>
				
				<option value="file10">github.com/reecetech/ebs-bootstrap/internal/model/device.go (77.8%)</option>
				
				<option value="file11">github.com/reecetech/ebs-bootstrap/internal/model/file.go (92.9%)</option>
				
				<option value="file12">github.com/reecetech/ebs-bootstrap/internal/model/filesystem.go (100.0%)</option>
				
				<option value="file13">github.com/reecetech/ebs-bootstrap/internal/service/device.go (100.0%)</option>
				
				<option value="file14">github.com/reecetech/ebs-bootstrap/internal/service/file.go (100.0%)</option>
				
				<option value="file15">github.com/reecetech/ebs-bootstrap/internal/service/filesystem.go (90.1%)</option>
				
				<option value="file16">github.com/reecetech/ebs-bootstrap/internal/service/mock.go (0.0%)</option>
				
				<option value="file17">github.com/reecetech/ebs-bootstrap/internal/service/nvme.go (61.9%)</option>
				
				<option value="file18">github.com/reecetech/ebs-bootstrap/internal/service/owner.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package action

import (
        "fmt"
        "log"
        "strings"

        "github.com/reecetech/ebs-bootstrap/internal/model"
)

type Action interface {
        Execute() error
        Success() string
        Prompt() string
        Refuse() string
        GetMode() model.Mode
        SetMode(mode model.Mode) Action
}

type ActionExecutor interface {
        Execute(actions []Action) error
}

type DefaultActionExecutor struct {
        read func(buffer *string) error
}

func NewDefaultActionExecutor() *DefaultActionExecutor <span class="cov0" title="0">{
        return &amp;DefaultActionExecutor{
                read: func(buffer *string) error </span><span class="cov0" title="0">{
                        _, err := fmt.Scanln(buffer)
                        return err
                }</span>,
        }
}

func (dae *DefaultActionExecutor) Execute(actions []Action) error <span class="cov8" title="1">{
        for _, a := range actions </span><span class="cov8" title="1">{
                err := dae.execute(a)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (dae *DefaultActionExecutor) execute(action Action) error <span class="cov8" title="1">{
        switch action.GetMode() </span>{
        case model.Force:<span class="cov8" title="1">
                break</span>
        case model.Prompt:<span class="cov8" title="1">
                if !dae.shouldProceed(action) </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ Action rejected. %s", action.Refuse())
                }</span>
        case model.Healthcheck:<span class="cov8" title="1">
                return fmt.Errorf("üî¥ Healthcheck mode enabled. %s", action.Refuse())</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("üî¥ Unsupported mode was encountered. %s", action.Refuse())</span>
        }

        <span class="cov8" title="1">if err := action.Execute(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">log.Printf("‚≠ê %s", action.Success())
        return nil</span>
}

func (dae *DefaultActionExecutor) shouldProceed(action Action) bool <span class="cov8" title="1">{
        prompt := action.Prompt()

        fmt.Printf("üü£ %s? (y/n): ", prompt)
        var response string
        err := dae.read(&amp;response)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">response = strings.ToLower(response)
        if response == "y" || response == "yes" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package action

import (
        "fmt"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type CreateDirectoryAction struct {
        path        string
        mode        model.Mode
        fileService service.FileService
}

func NewCreateDirectoryAction(p string, fs service.FileService) *CreateDirectoryAction <span class="cov0" title="0">{
        return &amp;CreateDirectoryAction{
                path:        p,
                mode:        model.Empty,
                fileService: fs,
        }
}</span>

func (a *CreateDirectoryAction) Execute() error <span class="cov0" title="0">{
        return a.fileService.CreateDirectory(a.path)
}</span>

func (a *CreateDirectoryAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *CreateDirectoryAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *CreateDirectoryAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to recursively create directory %s", a.path)
}</span>

func (a *CreateDirectoryAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to create directory %s", a.path)
}</span>

func (a *CreateDirectoryAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully created directory %s", a.path)
}</span>

type ChangeOwnerAction struct {
        path        string
        uid         model.UserId
        gid         model.GroupId
        mode        model.Mode
        fileService service.FileService
}

func NewChangeOwnerAction(p string, uid model.UserId, gid model.GroupId, fs service.FileService) *ChangeOwnerAction <span class="cov0" title="0">{
        return &amp;ChangeOwnerAction{
                path:        p,
                uid:         uid,
                gid:         gid,
                mode:        model.Empty,
                fileService: fs,
        }
}</span>

func (a *ChangeOwnerAction) Execute() error <span class="cov0" title="0">{
        return a.fileService.ChangeOwner(a.path, a.uid, a.gid)
}</span>

func (a *ChangeOwnerAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *ChangeOwnerAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *ChangeOwnerAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to change ownership (%d:%d) of %s", a.uid, a.gid, a.path)
}</span>

func (a *ChangeOwnerAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to to change ownership (%d:%d) of %s", a.uid, a.gid, a.path)
}</span>

func (a *ChangeOwnerAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully changed ownership (%d:%d) of %s", a.uid, a.gid, a.path)
}</span>

type ChangePermissionsAction struct {
        path        string
        perms       model.FilePermissions
        mode        model.Mode
        fileService service.FileService
}

func NewChangePermissions(p string, perms model.FilePermissions, fs service.FileService) *ChangePermissionsAction <span class="cov0" title="0">{
        return &amp;ChangePermissionsAction{
                path:        p,
                perms:       perms,
                mode:        model.Empty,
                fileService: fs,
        }
}</span>

func (a *ChangePermissionsAction) Execute() error <span class="cov0" title="0">{
        return a.fileService.ChangePermissions(a.path, a.perms)
}</span>

func (a *ChangePermissionsAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *ChangePermissionsAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *ChangePermissionsAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to change permissions of %s to %#o", a.path, a.perms)
}</span>

func (a *ChangePermissionsAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to to change permissions of %s to %#o", a.path, a.perms)
}</span>

func (a *ChangePermissionsAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully change permissions of %s to %#o", a.path, a.perms)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package action

import (
        "fmt"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type FormatDeviceAction struct {
        device            string
        fileSystemService service.FileSystemService
        mode              model.Mode
}

func NewFormatDeviceAction(d string, fileSystemService service.FileSystemService) *FormatDeviceAction <span class="cov0" title="0">{
        return &amp;FormatDeviceAction{
                device:            d,
                fileSystemService: fileSystemService,
                mode:              model.Empty,
        }
}</span>

func (a *FormatDeviceAction) Execute() error <span class="cov0" title="0">{
        return a.fileSystemService.Format(a.device)
}</span>

func (a *FormatDeviceAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *FormatDeviceAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *FormatDeviceAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to format %s to %s", a.device, a.fileSystemService.GetFileSystem())
}</span>

func (a *FormatDeviceAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to format to %s", a.fileSystemService.GetFileSystem())
}</span>

func (a *FormatDeviceAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully formated to %s", a.fileSystemService.GetFileSystem())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package action

import (
        "fmt"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type LabelDeviceAction struct {
        device            string
        label             string
        fileSystemService service.FileSystemService
        mode              model.Mode
}

func NewLabelDeviceAction(d string, label string, fileSystemService service.FileSystemService) *LabelDeviceAction <span class="cov0" title="0">{
        return &amp;LabelDeviceAction{
                device:            d,
                label:             label,
                fileSystemService: fileSystemService,
                mode:              model.Empty,
        }
}</span>

func (a *LabelDeviceAction) Execute() error <span class="cov0" title="0">{
        return a.fileSystemService.Label(a.device, a.label)
}</span>

func (a *LabelDeviceAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *LabelDeviceAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *LabelDeviceAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to label device %s to '%s'", a.device, a.label)
}</span>

func (a *LabelDeviceAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to label to '%s'", a.label)
}</span>

func (a *LabelDeviceAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully labelled to '%s'", a.label)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package action

import (
        "fmt"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type MountDeviceAction struct {
        source        string
        target        string
        fileSystem    model.FileSystem
        options       model.MountOptions
        deviceService service.DeviceService
        mode          model.Mode
}

func NewMountDeviceAction(source string, target string, fileSystem model.FileSystem, options model.MountOptions, deviceService service.DeviceService) *MountDeviceAction <span class="cov0" title="0">{
        return &amp;MountDeviceAction{
                source:        source,
                target:        target,
                fileSystem:    fileSystem,
                options:       options,
                deviceService: deviceService,
                mode:          model.Empty,
        }
}</span>

func (a *MountDeviceAction) Execute() error <span class="cov0" title="0">{
        return a.deviceService.Mount(a.source, a.target, a.fileSystem, a.options)
}</span>

func (a *MountDeviceAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *MountDeviceAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *MountDeviceAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to mount %s to %s (%s)", a.source, a.target, a.options)
}</span>

func (a *MountDeviceAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to mount %s to %s (%s)", a.source, a.target, a.options)
}</span>

func (a *MountDeviceAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully mounted %s to %s (%s)", a.source, a.target, a.options)
}</span>

type UnmountDeviceAction struct {
        source        string
        target        string
        deviceService service.DeviceService
        mode          model.Mode
}

func NewUnmountDeviceAction(source string, target string, deviceService service.DeviceService) *UnmountDeviceAction <span class="cov0" title="0">{
        return &amp;UnmountDeviceAction{
                source:        source,
                target:        target,
                deviceService: deviceService,
                mode:          model.Empty,
        }
}</span>

func (a *UnmountDeviceAction) Execute() error <span class="cov0" title="0">{
        return a.deviceService.Umount(a.source, a.target)
}</span>

func (a *UnmountDeviceAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *UnmountDeviceAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *UnmountDeviceAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to unmount %s from %s", a.source, a.target)
}</span>

func (a *UnmountDeviceAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to unmount %s from %s", a.source, a.target)
}</span>

func (a *UnmountDeviceAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully unmounted %s from %s", a.source, a.target)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package action

import (
        "fmt"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type ResizeDeviceAction struct {
        device            string
        target            string
        fileSystemService service.FileSystemService
        mode              model.Mode
}

func NewResizeDeviceAction(d string, target string, fileSystemService service.FileSystemService) *ResizeDeviceAction <span class="cov0" title="0">{
        return &amp;ResizeDeviceAction{
                device:            d,
                target:            target,
                fileSystemService: fileSystemService,
                mode:              model.Empty,
        }
}</span>

func (a *ResizeDeviceAction) Execute() error <span class="cov0" title="0">{
        return a.fileSystemService.Resize(a.target)
}</span>

func (a *ResizeDeviceAction) GetMode() model.Mode <span class="cov0" title="0">{
        return a.mode
}</span>

func (a *ResizeDeviceAction) SetMode(mode model.Mode) Action <span class="cov0" title="0">{
        a.mode = mode
        return a
}</span>

func (a *ResizeDeviceAction) Prompt() string <span class="cov0" title="0">{
        return fmt.Sprintf("Would you like to resize the %s file system of %s", a.fileSystemService.GetFileSystem(), a.device)
}</span>

func (a *ResizeDeviceAction) Refuse() string <span class="cov0" title="0">{
        return fmt.Sprintf("Refused to resize the %s file system of %s", a.fileSystemService.GetFileSystem(), a.device)
}</span>

func (a *ResizeDeviceAction) Success() string <span class="cov0" title="0">{
        return fmt.Sprintf("Successfully resized the %s file system of %s", a.fileSystemService.GetFileSystem(), a.device)
}</span>

func (a *ResizeDeviceAction) Warning() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "bytes"
        "flag"
        "fmt"
        "os"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "gopkg.in/yaml.v2"
)

const (
        DefaultMode         = model.Healthcheck
        DefaultMountOptions = model.MountOptions("defaults")
)

type Flag struct {
        Config          string
        Mode            string
        Remount         bool
        MountOptions    string
        ResizeFs        bool
        ResizeThreshold float64
}

type Device struct {
        Fs          model.FileSystem      `yaml:"fs"`
        MountPoint  string                `yaml:"mountPoint"`
        User        string                `yaml:"user"`
        Group       string                `yaml:"group"`
        Label       string                `yaml:"label"`
        Permissions model.FilePermissions `yaml:"permissions"`
        Options     `yaml:",inline"`
}

type Options struct {
        Mode            model.Mode         `yaml:"mode"`
        Remount         bool               `yaml:"remount"`
        MountOptions    model.MountOptions `yaml:"mountOptions"`
        ResizeFs        bool               `yaml:"resizeFs"`
        ResizeThreshold float64            `yaml:"resizeThreshold"`
}

// We don't export "overrides" as this is an attribute that is used
// internally to store the state of flag overrides
type Config struct {
        Defaults  Options           `yaml:"defaults"`
        Devices   map[string]Device `yaml:"devices"`
        overrides Options
}

func New(args []string) (*Config, error) <span class="cov8" title="1">{
        // Generate config path
        f, err := parseFlags(args[0], args[1:])
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprint(os.Stderr, err)
                return nil, fmt.Errorf("üî¥ Failed to parse provided flags")
        }</span>

        // Load config file into memory
        <span class="cov8" title="1">file, err := os.ReadFile(f.Config)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("üî¥ %s: File not found", f.Config)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("üî¥ %s: %v", f.Config, err)</span>
        }

        // Create config structure
        <span class="cov8" title="1">c := &amp;Config{}

        // Unmarshal YAML file from memory into struct
        err = yaml.UnmarshalStrict(file, c)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintln(os.Stderr, err)
                return nil, fmt.Errorf("üî¥ %s: Failed to ingest malformed config", f.Config)
        }</span>

        // Inject flag overrides into config
        <span class="cov8" title="1">return c.setOverrides(f), nil</span>
}

func parseFlags(program string, args []string) (*Flag, error) <span class="cov8" title="1">{
        flags := flag.NewFlagSet(program, flag.ContinueOnError)
        var buf bytes.Buffer
        flags.SetOutput(&amp;buf)

        // String that contains the configured configuration path
        f := &amp;Flag{}
        // String that contains the mode of bootstrap process

        // Set up a CLI flag called "-config" to allow users
        // to supply the configuration file
        flags.StringVar(&amp;f.Config, "config", "/etc/ebs-bootstrap/config.yml", "path to config file")
        flags.StringVar(&amp;f.Mode, "mode", "", "override for mode")
        flags.BoolVar(&amp;f.Remount, "remount", false, "override for remount")
        flags.StringVar(&amp;f.MountOptions, "mount-options", "", "override for mount options")
        flags.BoolVar(&amp;f.ResizeFs, "resize-fs", false, "override for resize filesystem")
        flags.Float64Var(&amp;f.ResizeThreshold, "resize-threshold", 0, "override for resize threshold")

        // Actually parse the flag
        err := flags.Parse(args)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(buf.String())
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

func (c *Config) setOverrides(f *Flag) *Config <span class="cov8" title="1">{
        c.overrides.Mode = model.Mode(f.Mode)
        c.overrides.Remount = f.Remount
        c.overrides.MountOptions = model.MountOptions(f.MountOptions)
        c.overrides.ResizeFs = f.ResizeFs
        c.overrides.ResizeThreshold = f.ResizeThreshold
        return c
}</span>

func (c *Config) GetMode(name string) model.Mode <span class="cov8" title="1">{
        cd, found := c.Devices[name]
        if !found </span><span class="cov8" title="1">{
                return DefaultMode
        }</span>
        <span class="cov8" title="1">if c.overrides.Mode != model.Empty </span><span class="cov8" title="1">{
                return c.overrides.Mode
        }</span>
        <span class="cov8" title="1">if cd.Mode != model.Empty </span><span class="cov8" title="1">{
                return cd.Mode
        }</span>
        <span class="cov8" title="1">if c.Defaults.Mode != model.Empty </span><span class="cov8" title="1">{
                return c.Defaults.Mode
        }</span>
        <span class="cov8" title="1">return DefaultMode</span>
}

func (c *Config) GetRemount(name string) bool <span class="cov8" title="1">{
        cd, found := c.Devices[name]
        if !found </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return c.overrides.Remount || c.Defaults.Remount || cd.Remount</span>
}

func (c *Config) GetMountOptions(name string) model.MountOptions <span class="cov8" title="1">{
        cd, found := c.Devices[name]
        if !found </span><span class="cov8" title="1">{
                return DefaultMountOptions
        }</span>
        <span class="cov8" title="1">if len(c.overrides.MountOptions) &gt; 0 </span><span class="cov8" title="1">{
                return c.overrides.MountOptions
        }</span>
        <span class="cov8" title="1">if len(cd.MountOptions) &gt; 0 </span><span class="cov8" title="1">{
                return cd.MountOptions
        }</span>
        <span class="cov8" title="1">if len(c.Defaults.MountOptions) &gt; 0 </span><span class="cov8" title="1">{
                return c.Defaults.MountOptions
        }</span>
        <span class="cov8" title="1">return DefaultMountOptions</span>
}

func (c *Config) GetResizeFs(name string) bool <span class="cov8" title="1">{
        cd, found := c.Devices[name]
        if !found </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return c.overrides.ResizeFs || c.Defaults.ResizeFs || cd.ResizeFs</span>
}

func (c *Config) GetResizeThreshold(name string) float64 <span class="cov8" title="1">{
        cd, found := c.Devices[name]
        if !found </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if c.overrides.ResizeThreshold &gt; 0 </span><span class="cov8" title="1">{
                return c.overrides.ResizeThreshold
        }</span>
        <span class="cov8" title="1">if cd.ResizeThreshold &gt; 0 </span><span class="cov8" title="1">{
                return cd.ResizeThreshold
        }</span>
        <span class="cov8" title="1">return c.Defaults.ResizeThreshold</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "log"
        "strings"

        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type Modifier interface {
        Modify(c *Config) error
}

type AwsNitroNVMeModifier struct {
        nvmeService   service.NVMeService
        deviceService service.DeviceService
}

func NewAwsNVMeDriverModifier(nvmeService service.NVMeService, deviceService service.DeviceService) *AwsNitroNVMeModifier <span class="cov8" title="1">{
        return &amp;AwsNitroNVMeModifier{
                nvmeService:   nvmeService,
                deviceService: deviceService,
        }
}</span>

func (andm *AwsNitroNVMeModifier) Modify(c *Config) error <span class="cov8" title="1">{
        bds, err := andm.deviceService.GetBlockDevices()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for _, name := range bds </span><span class="cov8" title="1">{
                // Check if device already exists in the config
                // No need to make additional queries if this is the case
                _, exists := c.Devices[name]
                if exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.HasPrefix(name, "/dev/nvme") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">bdm, err := andm.nvmeService.GetBlockDeviceMapping(name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">cd, exists := c.Devices[bdm]
                // We can detect AWS NVMe Devices, but this doesn't neccesarily
                // mean they will be managed through configuration
                if !exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">log.Printf("üîµ %s: Detected Nitro-based AWS NVMe device =&gt; %s", name, bdm)
                // Delete the original reference to the device configuration from the
                // block device mapping retrieved from the NVMe IoCtl interface and
                // replace it with the actual device name
                //        Before:
                //                 /dev/sdb =&gt; *config.Device (a)
                //        After:
                //                /dev/nvme0n1 =&gt; *config.Device (a)
                c.Devices[name] = cd
                delete(c.Devices, bdm)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"
        "path"
        "strings"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/service"
)

type Validator interface {
        Validate(c *Config) error
}

type DeviceValidator struct {
        deviceService service.DeviceService
}

func NewDeviceValidator(ds service.DeviceService) *DeviceValidator <span class="cov8" title="1">{
        return &amp;DeviceValidator{
                deviceService: ds,
        }
}</span>

func (dv *DeviceValidator) Validate(c *Config) error <span class="cov8" title="1">{
        for name := range c.Devices </span><span class="cov8" title="1">{
                _, err := dv.deviceService.GetBlockDevice(name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type FileSystemValidator struct{}

func NewFileSystemValidator() *FileSystemValidator <span class="cov8" title="1">{
        return &amp;FileSystemValidator{}
}</span>

func (fsv *FileSystemValidator) Validate(c *Config) error <span class="cov8" title="1">{
        for name, device := range c.Devices </span><span class="cov8" title="1">{
                fs, err := model.ParseFileSystem(string(device.Fs))
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ %s: '%s' is not a supported file system", name, fs)
                }</span>
                <span class="cov8" title="1">if fs == model.Unformatted </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ %s: Must provide a supported file system", name)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type ModeValidator struct{}

func NewModeValidator() *ModeValidator <span class="cov8" title="1">{
        return &amp;ModeValidator{}
}</span>

func (fsv *ModeValidator) Validate(c *Config) error <span class="cov8" title="1">{
        mode := string(c.Defaults.Mode)
        _, err := model.ParseMode(mode)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%s' (defaults) is not a supported mode", mode)
        }</span>

        <span class="cov8" title="1">mode = string(c.overrides.Mode)
        _, err = model.ParseMode(mode)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%s' (-mode) is not a supported mode", mode)
        }</span>

        <span class="cov8" title="1">for name, device := range c.Devices </span><span class="cov8" title="1">{
                mode := string(device.Mode)
                _, err := model.ParseMode(mode)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ %s: '%s' is not a supported mode", name, mode)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type MountPointValidator struct{}

func NewMountPointValidator() *MountPointValidator <span class="cov8" title="1">{
        return &amp;MountPointValidator{}
}</span>

func (apv *MountPointValidator) Validate(c *Config) error <span class="cov8" title="1">{
        for name, device := range c.Devices </span><span class="cov8" title="1">{
                if len(device.MountPoint) &gt; 0 </span><span class="cov8" title="1">{
                        if !path.IsAbs(device.MountPoint) </span><span class="cov8" title="1">{
                                return fmt.Errorf("üî¥ %s: %s is not an absolute path", name, device.MountPoint)
                        }</span>
                        <span class="cov8" title="1">if device.MountPoint == "/" </span><span class="cov8" title="1">{
                                return fmt.Errorf("üî¥ %s: Can not be mounted to the root directory", name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type MountOptionsValidator struct{}

func NewMountOptionsValidator() *MountOptionsValidator <span class="cov8" title="1">{
        return &amp;MountOptionsValidator{}
}</span>

func (mov *MountOptionsValidator) Validate(c *Config) error <span class="cov8" title="1">{
        mo := string(c.Defaults.MountOptions)
        if err := mov.validate(mo); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%s' (defaults) is not a supported mode as %s", mo, err)
        }</span>
        <span class="cov8" title="1">mo = string(c.overrides.MountOptions)
        if err := mov.validate(mo); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%s' (-mount-options) is not a supported mode as %s", mo, err)
        }</span>
        <span class="cov8" title="1">for name, device := range c.Devices </span><span class="cov8" title="1">{
                mo := string(device.MountOptions)
                if err := mov.validate(mo); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ %s: '%s' is not a supported mode as %s", name, mo, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (mov *MountOptionsValidator) validate(mo string) error <span class="cov8" title="1">{
        if strings.Contains(mo, "remount") </span><span class="cov8" title="1">{
                return fmt.Errorf("it prevents unmounted devices from being mounted")
        }</span>
        <span class="cov8" title="1">if strings.Contains(mo, "bind") </span><span class="cov8" title="1">{
                return fmt.Errorf("bind mounts are not supported for block devices")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type OwnerValidator struct {
        ownerService service.OwnerService
}

func NewOwnerValidator(ows service.OwnerService) *OwnerValidator <span class="cov8" title="1">{
        return &amp;OwnerValidator{
                ownerService: ows,
        }
}</span>

func (ov *OwnerValidator) Validate(c *Config) error <span class="cov8" title="1">{
        for _, device := range c.Devices </span><span class="cov8" title="1">{
                if len(device.User) &gt; 0 </span><span class="cov8" title="1">{
                        _, err := ov.ownerService.GetUser(device.User)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if len(device.Group) &gt; 0 </span><span class="cov8" title="1">{
                        _, err := ov.ownerService.GetGroup(device.Group)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type ResizeThresholdValidator struct{}

func NewResizeThresholdValidator() *ResizeThresholdValidator <span class="cov8" title="1">{
        return &amp;ResizeThresholdValidator{}
}</span>

func (rtv *ResizeThresholdValidator) Validate(c *Config) error <span class="cov8" title="1">{
        if !rtv.isValid(c.Defaults.ResizeThreshold) </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%g' (default) must be a floating point between 0 and 100 (inclusive)", c.Defaults.ResizeThreshold)
        }</span>
        <span class="cov8" title="1">if !rtv.isValid(c.overrides.ResizeThreshold) </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ '%g' (-resize-threshold) must be a floating point between 0 and 100 (inclusive)", c.overrides.ResizeThreshold)
        }</span>
        <span class="cov8" title="1">for name, device := range c.Devices </span><span class="cov8" title="1">{
                if !rtv.isValid(device.ResizeThreshold) </span><span class="cov8" title="1">{
                        return fmt.Errorf("üî¥ %s: '%g' must be a floating point between 0 and 100 (inclusive)", name, device.ResizeThreshold)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rtv *ResizeThresholdValidator) isValid(rt float64) bool <span class="cov8" title="1">{
        return rt &gt;= 0 &amp;&amp; rt &lt;= 100
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package model

import (
        "fmt"
)

type Mode string

const (
        Empty       Mode = ""
        Healthcheck Mode = "healthcheck"
        Prompt      Mode = "prompt"
        Force       Mode = "force"
)

func ParseMode(s string) (Mode, error) <span class="cov8" title="1">{
        m := Mode(s)
        switch m </span>{
        case Empty, Healthcheck, Prompt, Force:<span class="cov8" title="1">
                return m, nil</span>
        default:<span class="cov8" title="1">
                return m, fmt.Errorf("üî¥ Mode '%s' is not supported", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package model

import (
        "slices"
        "strings"
)

type BlockDevice struct {
        Name       string
        MountPoint string
        FileSystem FileSystem
        Label      string
}

type MountOptions string

func (mop MountOptions) Remount() MountOptions <span class="cov8" title="1">{
        mops := []string{}
        if len(mop) &gt; 0 </span><span class="cov8" title="1">{
                mops = strings.Split(string(mop), ",")
        }</span>

        // Return -1 if not found
        <span class="cov8" title="1">index := slices.Index(mops, "remount")
        if index &lt; 0 </span><span class="cov8" title="1">{
                mops = append(mops, "remount")
        }</span>
        <span class="cov8" title="1">return MountOptions(strings.Join(mops, ","))</span>
}

type BlockDeviceMetrics struct {
        FileSystemSize  uint64
        BlockDeviceSize uint64
}

func (bdm *BlockDeviceMetrics) ShouldResize(threshold float64) bool <span class="cov0" title="0">{
        // Minimum File System Size (mfss)
        mfss := float64(bdm.BlockDeviceSize) * (threshold / 100)
        return float64(bdm.FileSystemSize) &lt; mfss
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package model

import (
        "fmt"
        "io/fs"
        "strconv"
)

type FileType uint32

const (
        RegularFile FileType = 0
        Directory   FileType = 1
        Special     FileType = 2
)

type File struct {
        Path     string
        Type     FileType
        DeviceId uint64
        InodeNo  uint64
        UserId
        GroupId
        Permissions FilePermissions
}

type FilePermissions uint32

// It is useful to be able to convert FilePermissions back into the fs.FileMode
// type which is expected by Go standard libraries
func (p FilePermissions) Perm() fs.FileMode <span class="cov8" title="1">{
        return fs.FileMode(p)
}</span>

// Linux File Permission bits are typically represented as octals: e.g 0755.
// Some users may feel comfortable representing file permission bits as decimals:
// e.g 755. While the latter is not considered an octal, lets not punish them
// for a behaviour that has been ingrained by tools like chmod.
// `strconv.ParseUint` has the ability to force the intepreation of a string as a base-8
// unsigned integer
func (p *FilePermissions) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        var ps string
        if err := unmarshal(&amp;ps); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(ps) == 0 </span><span class="cov8" title="1">{
                *p = FilePermissions(0)
                return nil
        }</span>
        // Base: 8, Bit Length: 32
        <span class="cov8" title="1">mode, err := strconv.ParseUint(ps, 8, 32)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ invalid permission value. '%v' must be a valid octal number", ps)
        }</span>
        <span class="cov8" title="1">if mode &gt; 0777 </span><span class="cov8" title="1">{
                return fmt.Errorf("üî¥ invalid permission value. '%#o' exceeds the maximum allowed value (0777)", mode)
        }</span>
        <span class="cov8" title="1">*p = FilePermissions(mode)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import "fmt"

type FileSystem string

const (
        Unformatted FileSystem = ""
        Ext4        FileSystem = "ext4"
        Xfs         FileSystem = "xfs"
)

func ParseFileSystem(s string) (FileSystem, error) <span class="cov8" title="1">{
        fst := FileSystem(s)
        switch fst </span>{
        case Unformatted, Ext4, Xfs:<span class="cov8" title="1">
                return fst, nil</span>
        default:<span class="cov8" title="1">
                return fst, fmt.Errorf("üî¥ File system '%s' is not supported", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "strconv"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/utils"
)

type DeviceService interface {
        GetSize(name string) (uint64, error) // bytes
        GetBlockDevices() ([]string, error)
        GetBlockDevice(name string) (*model.BlockDevice, error)
        Mount(source string, target string, fs model.FileSystem, options model.MountOptions) error
        Umount(source string, target string) error
}

type LinuxDeviceService struct {
        runnerFactory utils.RunnerFactory
}

type LsblkBlockDeviceResponse struct {
        BlockDevices []LsblkBlockDevice `json:"blockdevices"`
}

type LsblkBlockDevice struct {
        Name       *string `json:"name"`
        Label      *string `json:"label"`
        FsType     *string `json:"fstype"`
        MountPoint *string `json:"mountpoint"`
}

func NewLinuxDeviceService(rc utils.RunnerFactory) *LinuxDeviceService <span class="cov8" title="1">{
        return &amp;LinuxDeviceService{
                runnerFactory: rc,
        }
}</span>

func (du *LinuxDeviceService) GetSize(name string) (uint64, error) <span class="cov8" title="1">{
        r := du.runnerFactory.Select(utils.BlockDev)
        output, err := r.Command("--getsize64", name)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">b, err := strconv.ParseUint(output, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("üî¥ Failed to cast block device size to unsigned 64-bit integer")
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

func (du *LinuxDeviceService) GetBlockDevices() ([]string, error) <span class="cov8" title="1">{
        r := du.runnerFactory.Select(utils.Lsblk)
        output, err := r.Command("--nodeps", "-o", "NAME", "-J")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">lbd := &amp;LsblkBlockDeviceResponse{}
        err = json.Unmarshal([]byte(output), lbd)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("üî¥ Failed to decode lsblk response: %v", err)
        }</span>
        <span class="cov8" title="1">d := make([]string, len(lbd.BlockDevices))
        for i := range d </span><span class="cov8" title="1">{
                d[i] = "/dev/" + utils.Safe(lbd.BlockDevices[i].Name)
        }</span>
        <span class="cov8" title="1">return d, nil</span>
}

func (du *LinuxDeviceService) GetBlockDevice(name string) (*model.BlockDevice, error) <span class="cov8" title="1">{
        r := du.runnerFactory.Select(utils.Lsblk)
        output, err := r.Command("--nodeps", "-o", "LABEL,FSTYPE,MOUNTPOINT", "-J", name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">lbd := &amp;LsblkBlockDeviceResponse{}
        err = json.Unmarshal([]byte(output), lbd)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("üî¥ Failed to decode lsblk response: %v", err)
        }</span>
        <span class="cov8" title="1">if len(lbd.BlockDevices) != 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("üî¥ %s: An unexpected number of block devices were returned: Expected=1 Actual=%d", name, len(lbd.BlockDevices))
        }</span>
        <span class="cov8" title="1">fst := utils.Safe(lbd.BlockDevices[0].FsType)
        fs, err := model.ParseFileSystem(fst)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("üî¥ %s: '%s' is not a supported file system", name, fst)
        }</span>
        <span class="cov8" title="1">return &amp;model.BlockDevice{
                Name:       name,
                Label:      utils.Safe(lbd.BlockDevices[0].Label),
                FileSystem: fs,
                MountPoint: utils.Safe(lbd.BlockDevices[0].MountPoint),
        }, nil</span>
}

func (du *LinuxDeviceService) Mount(source string, target string, fs model.FileSystem, options model.MountOptions) error <span class="cov8" title="1">{
        r := du.runnerFactory.Select(utils.Mount)
        _, err := r.Command(source, "-t", string(fs), "-o", string(options), target)
        return err
}</span>

func (du *LinuxDeviceService) Umount(source string, target string) error <span class="cov8" title="1">{
        r := du.runnerFactory.Select(utils.Umount)
        _, err := r.Command(target)
        return err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "os"
        "syscall"

        "github.com/reecetech/ebs-bootstrap/internal/model"
)

const (
        DefaultDirectoryPermissions = os.FileMode(0755)
)

// File Service Interface [START]

type FileService interface {
        GetFile(file string) (*model.File, error)
        CreateDirectory(path string) error
        ChangeOwner(file string, uid model.UserId, gid model.GroupId) error
        ChangePermissions(file string, perms model.FilePermissions) error
}

// File Service Interface [END]

type UnixFileService struct{}

func NewUnixFileService() *UnixFileService <span class="cov8" title="1">{
        return &amp;UnixFileService{}
}</span>

func (ufs *UnixFileService) GetFile(file string) (*model.File, error) <span class="cov8" title="1">{
        info, err := os.Lstat(file)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // This program will be exclusively run on Unix-based systems.
        // The os.FileInfo interface's Sys() method is documented to return a *syscall.Stat_t on Unix systems
        // Therefore, we can safely perform this type cast, without performing an assertion check
        <span class="cov8" title="1">stat := info.Sys().(*syscall.Stat_t)

        var ft model.FileType
        switch mode := info.Mode(); </span>{
        case mode.IsRegular():<span class="cov8" title="1">
                ft = model.RegularFile</span>
        case mode.IsDir():<span class="cov8" title="1">
                ft = model.Directory</span>
        default:<span class="cov8" title="1">
                ft = model.Special</span>
        }

        <span class="cov8" title="1">return &amp;model.File{
                Path:        file,
                DeviceId:    stat.Dev,
                InodeNo:     stat.Ino,
                UserId:      model.UserId(stat.Uid),
                GroupId:     model.GroupId(stat.Gid),
                Permissions: model.FilePermissions(info.Mode().Perm()),
                Type:        ft,
        }, nil</span>
}

func (ufs *UnixFileService) CreateDirectory(path string) error <span class="cov8" title="1">{
        return os.MkdirAll(path, DefaultDirectoryPermissions)
}</span>

func (ufs *UnixFileService) ChangeOwner(file string, uid model.UserId, gid model.GroupId) error <span class="cov8" title="1">{
        return os.Chown(file, int(uid), int(gid))
}</span>

func (ufs *UnixFileService) ChangePermissions(file string, perms model.FilePermissions) error <span class="cov8" title="1">{
        return os.Chmod(file, perms.Perm())
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import (
        "fmt"
        "regexp"
        "strconv"

        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/utils"
)

type FileSystemService interface {
        GetSize(name string) (uint64, error) // (bytes)
        GetFileSystem() model.FileSystem
        Format(name string) error
        Label(name string, label string) error
        Resize(name string) error
        GetMaximumLabelLength() int
        DoesResizeRequireMount() bool
        DoesLabelRequireUnmount() bool
}

type FileSystemServiceFactory interface {
        Select(fs model.FileSystem) (FileSystemService, error)
}

type LinuxFileSystemServiceFactory struct {
        RunnerFactory utils.RunnerFactory
}

func NewLinuxFileSystemServiceFactory(rc utils.RunnerFactory) *LinuxFileSystemServiceFactory <span class="cov8" title="1">{
        return &amp;LinuxFileSystemServiceFactory{
                RunnerFactory: rc,
        }
}</span>

func (fsf *LinuxFileSystemServiceFactory) Select(fs model.FileSystem) (FileSystemService, error) <span class="cov8" title="1">{
        switch fs </span>{
        case model.Ext4:<span class="cov8" title="1">
                return NewExt4Service(fsf.RunnerFactory), nil</span>
        case model.Xfs:<span class="cov8" title="1">
                return NewXfsService(fsf.RunnerFactory), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("üî¥ An unsupported filesystem was encountered")</span>
        }
}

type Ext4Service struct {
        runnerFactory utils.RunnerFactory
}

func NewExt4Service(rc utils.RunnerFactory) *Ext4Service <span class="cov8" title="1">{
        return &amp;Ext4Service{runnerFactory: rc}
}</span>

func (es *Ext4Service) GetFileSystem() model.FileSystem <span class="cov8" title="1">{
        return model.Ext4
}</span>

func (es *Ext4Service) Format(name string) error <span class="cov8" title="1">{
        r := es.runnerFactory.Select(utils.MkfsExt4)
        _, err := r.Command(name)
        return err
}</span>

func (es *Ext4Service) Label(name string, label string) error <span class="cov8" title="1">{
        r := es.runnerFactory.Select(utils.E2Label)
        _, err := r.Command(name, label)
        return err
}</span>

func (es *Ext4Service) Resize(name string) error <span class="cov8" title="1">{
        r := es.runnerFactory.Select(utils.Resize2fs)
        _, err := r.Command(name)
        return err
}</span>

func (es *Ext4Service) GetSize(name string) (uint64, error) <span class="cov8" title="1">{
        r := es.runnerFactory.Select(utils.Tune2fs)
        output, err := r.Command("-l", name)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        // Regex (Block Size)
        <span class="cov8" title="1">rebs := regexp.MustCompile(`Block size:\s+(\d+)`)
        // Match (Block Size)
        mbs := rebs.FindStringSubmatch(output)
        if len(mbs) != 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ %s: Block size not found tune2fs output", name)
        }</span>
        // String (Block Size)
        <span class="cov8" title="1">sbs := mbs[1]
        // Block Size
        bs, err := strconv.ParseUint(sbs, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ Failed to cast block size to unsigned 64-bit integer")
        }</span>

        // Regex (Block Count)
        <span class="cov8" title="1">rebc := regexp.MustCompile(`Block count:\s+(\d+)`)
        // Match (Block Count)
        mbc := rebc.FindStringSubmatch(output)
        if len(mbs) != 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ %s: Block count not found tune2fs output", name)
        }</span>
        // String (Block Count)
        <span class="cov8" title="1">sbc := mbc[1]
        // Block Count
        bc, err := strconv.ParseUint(sbc, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ Failed to cast block size to unsigned 64-bit integer")
        }</span>
        <span class="cov8" title="1">return bs * bc, nil</span>
}

func (es *Ext4Service) GetMaximumLabelLength() int <span class="cov8" title="1">{
        return 16
}</span>

func (es *Ext4Service) DoesResizeRequireMount() bool <span class="cov8" title="1">{
        return false
}</span>

func (es *Ext4Service) DoesLabelRequireUnmount() bool <span class="cov8" title="1">{
        return false
}</span>

type XfsService struct {
        runnerFactory utils.RunnerFactory
}

func NewXfsService(rc utils.RunnerFactory) *XfsService <span class="cov8" title="1">{
        return &amp;XfsService{runnerFactory: rc}
}</span>

func (es *XfsService) GetFileSystem() model.FileSystem <span class="cov8" title="1">{
        return model.Xfs
}</span>

func (xs *XfsService) Format(name string) error <span class="cov8" title="1">{
        r := xs.runnerFactory.Select(utils.MkfsXfs)
        _, err := r.Command(name)
        return err
}</span>

func (xs *XfsService) Label(name string, label string) error <span class="cov8" title="1">{
        r := xs.runnerFactory.Select(utils.XfsAdmin)
        _, err := r.Command("-L", label, name)
        return err
}</span>

func (es *XfsService) Resize(name string) error <span class="cov8" title="1">{
        r := es.runnerFactory.Select(utils.XfsGrowfs)
        _, err := r.Command(name)
        return err
}</span>

func (xs *XfsService) GetSize(name string) (uint64, error) <span class="cov8" title="1">{
        r := xs.runnerFactory.Select(utils.XfsInfo)
        output, err := r.Command(name)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        // Regex (Data)
        <span class="cov8" title="1">red := regexp.MustCompile(`data\s+=\s+bsize=(\d+)\s+blocks=(\d+)`)
        // Match (Data)
        md := red.FindStringSubmatch(output)
        if len(md) != 3 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ %s: Block size and block count not found xfs_info output", name)
        }</span>
        // String (Block Size)
        <span class="cov8" title="1">sbs := md[1]
        // Block Size
        bs, err := strconv.ParseUint(sbs, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ Failed to cast block size to unsigned 64-bit integer")
        }</span>
        // String (Block Count)
        <span class="cov8" title="1">sbc := md[2]
        // Block Count
        bc, err := strconv.ParseUint(sbc, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("üî¥ Failed to cast block count to unsigned 64-bit integer")
        }</span>
        <span class="cov8" title="1">return bs * bc, nil</span>
}

func (es *XfsService) GetMaximumLabelLength() int <span class="cov8" title="1">{
        return 12
}</span>

func (es *XfsService) DoesResizeRequireMount() bool <span class="cov8" title="1">{
        return true
}</span>

func (es *XfsService) DoesLabelRequireUnmount() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "github.com/reecetech/ebs-bootstrap/internal/model"
        "github.com/reecetech/ebs-bootstrap/internal/utils"
)

type MockDeviceService struct {
        StubGetSize         func(name string) (uint64, error)
        StubGetBlockDevices func() ([]string, error)
        StubGetBlockDevice  func(name string) (*model.BlockDevice, error)
        StubMount           func(source string, target string, fs model.FileSystem, options model.MountOptions) error
        StubUmount          func(source string, target string) error
}

func NewMockDeviceService() *MockDeviceService <span class="cov0" title="0">{
        return &amp;MockDeviceService{
                StubGetSize: func(name string) (uint64, error) </span><span class="cov0" title="0">{
                        return 0, utils.NotImeplementedError("GetSize()")
                }</span>,
                StubGetBlockDevices: func() ([]string, error) <span class="cov0" title="0">{
                        return nil, utils.NotImeplementedError("GetBlockDevices()")
                }</span>,
                StubGetBlockDevice: func(name string) (*model.BlockDevice, error) <span class="cov0" title="0">{
                        return nil, utils.NotImeplementedError("GetBlockDevice()")
                }</span>,
                StubMount: func(source, target string, fs model.FileSystem, options model.MountOptions) error <span class="cov0" title="0">{
                        return utils.NotImeplementedError("Mount()")
                }</span>,
                StubUmount: func(source, target string) error <span class="cov0" title="0">{
                        return utils.NotImeplementedError("Umount()")
                }</span>,
        }
}

func (mds *MockDeviceService) GetSize(name string) (uint64, error) <span class="cov0" title="0">{
        return mds.StubGetSize(name)
}</span>

func (mds *MockDeviceService) GetBlockDevices() ([]string, error) <span class="cov0" title="0">{
        return mds.StubGetBlockDevices()
}</span>

func (mds *MockDeviceService) GetBlockDevice(name string) (*model.BlockDevice, error) <span class="cov0" title="0">{
        return mds.StubGetBlockDevice(name)
}</span>

func (mds *MockDeviceService) Mount(source string, target string, fs model.FileSystem, options model.MountOptions) error <span class="cov0" title="0">{
        return mds.StubMount(source, target, fs, options)
}</span>

func (mds *MockDeviceService) Umount(source string, target string) error <span class="cov0" title="0">{
        return mds.StubUmount(source, target)
}</span>

type MockOwnerService struct {
        StubGetCurrentUser func() (*model.User, error)
        StubGetUser        func(usr string) (*model.User, error)
        StubGetGroup       func(grp string) (*model.Group, error)
}

func NewMockOwnerService() *MockOwnerService <span class="cov0" title="0">{
        return &amp;MockOwnerService{
                StubGetCurrentUser: func() (*model.User, error) </span><span class="cov0" title="0">{
                        return nil, utils.NotImeplementedError("GetCurrentUser()")
                }</span>,
                StubGetUser: func(usr string) (*model.User, error) <span class="cov0" title="0">{
                        return nil, utils.NotImeplementedError("GetUser()")
                }</span>,
                StubGetGroup: func(grp string) (*model.Group, error) <span class="cov0" title="0">{
                        return nil, utils.NotImeplementedError("GetGroup()")
                }</span>,
        }
}

func (mos *MockOwnerService) GetCurrentUser() (*model.User, error) <span class="cov0" title="0">{
        return mos.StubGetCurrentUser()
}</span>

func (mos *MockOwnerService) GetUser(usr string) (*model.User, error) <span class="cov0" title="0">{
        return mos.StubGetUser(usr)
}</span>

func (mos *MockOwnerService) GetGroup(grp string) (*model.Group, error) <span class="cov0" title="0">{
        return mos.StubGetGroup(grp)
}</span>

type MockNVMeService struct {
        StubGetBlockDeviceMapping func(device string) (string, error)
}

func NewMockNVMeService() *MockNVMeService <span class="cov0" title="0">{
        return &amp;MockNVMeService{
                StubGetBlockDeviceMapping: func(device string) (string, error) </span><span class="cov0" title="0">{
                        return "", utils.NotImeplementedError("GetBlockDeviceMapping()")
                }</span>,
        }
}

func (mns *MockNVMeService) GetBlockDeviceMapping(device string) (string, error) <span class="cov0" title="0">{
        return mns.StubGetBlockDeviceMapping(device)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "fmt"
        "os"
        "regexp"
        "strings"
        "syscall"
        "unsafe"
)

const (
        NVME_ADMIN_IDENTIFY  = 0x06
        NVME_IOCTL_ADMIN_CMD = 0xC0484E41
        AMZN_NVME_VID        = 0x1D0F
        AMZN_NVME_EBS_MN     = "Amazon Elastic Block Store"
        AMZN_NVME_INS_MN     = "Amazon EC2 NVMe Instance Storage"
)

type nvmeAdminCommand struct {
        Opcode    uint8
        Flags     uint8
        Cid       uint16
        Nsid      uint32
        Reserved0 uint64
        Mptr      uint64
        Addr      uint64
        Mlen      uint32
        Alen      uint32
        Cdw10     uint32
        Cdw11     uint32
        Cdw12     uint32
        Cdw13     uint32
        Cdw14     uint32
        Cdw15     uint32
        Reserved1 uint64
}

type nvmeIdentifyControllerAmznVS struct {
        Bdev      [32]byte
        Reserved0 [1024 - 32]byte
}

type nvmeIdentifyControllerPSD struct {
        Mp        uint16
        Reserved0 uint16
        Enlat     uint32
        Exlat     uint32
        Rrt       uint8
        Rrl       uint8
        Rwt       uint8
        Rwl       uint8
        Reserved1 [16]byte
}

type nvmeIdentifyController struct {
        Vid       uint16
        Ssvid     uint16
        Sn        [20]byte
        Mn        [40]byte
        Fr        [8]byte
        Rab       uint8
        Ieee      [3]uint8
        Mic       uint8
        Mdts      uint8
        Reserved0 [256 - 78]byte
        Oacs      uint16
        Acl       uint8
        Aerl      uint8
        Frmw      uint8
        Lpa       uint8
        Elpe      uint8
        Npss      uint8
        Avscc     uint8
        Reserved1 [512 - 265]byte
        Sqes      uint8
        Cqes      uint8
        Reserved2 uint16
        Nn        uint32
        Oncs      uint16
        Fuses     uint16
        Fna       uint8
        Vwc       uint8
        Awun      uint16
        Awupf     uint16
        Nvscc     uint8
        Reserved3 [704 - 531]byte
        Reserved4 [2048 - 704]byte
        Psd       [32]nvmeIdentifyControllerPSD
        Vs        nvmeIdentifyControllerAmznVS
}

type NVMeIoctlResult struct {
        Name   string
        IdCtrl nvmeIdentifyController
}

func NewNVMeIoctlResult(name string) *NVMeIoctlResult <span class="cov0" title="0">{
        return &amp;NVMeIoctlResult{Name: name}
}</span>

func (d *NVMeIoctlResult) Syscall() error <span class="cov0" title="0">{
        idResponse := uintptr(unsafe.Pointer(&amp;d.IdCtrl))
        idLen := unsafe.Sizeof(d.IdCtrl)

        adminCmd := nvmeAdminCommand{
                Opcode: NVME_ADMIN_IDENTIFY,
                Addr:   uint64(idResponse),
                Alen:   uint32(idLen),
                Cdw10:  1,
        }

        nvmeFile, err := os.OpenFile(d.Name, os.O_RDONLY, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer nvmeFile.Close()

        _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, nvmeFile.Fd(), NVME_IOCTL_ADMIN_CMD, uintptr(unsafe.Pointer(&amp;adminCmd)))
        if errno != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("üî¥ ioctl error: %v", errno)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type NVMeService interface {
        GetBlockDeviceMapping(device string) (string, error)
}

type AwsNitroNVMeService struct{}

func NewAwsNitroNVMeService() *AwsNitroNVMeService <span class="cov8" title="1">{
        return &amp;AwsNitroNVMeService{}
}</span>

func (ns *AwsNitroNVMeService) GetBlockDeviceMapping(device string) (string, error) <span class="cov0" title="0">{
        nir := NewNVMeIoctlResult(device)
        if err := nir.Syscall(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return ns.getBlockDeviceMapping(nir)</span>
}

func (ns *AwsNitroNVMeService) isEBSVolume(nir *NVMeIoctlResult) bool <span class="cov8" title="1">{
        vid := nir.IdCtrl.Vid
        mn := strings.TrimRightFunc(string(nir.IdCtrl.Mn[:]), ns.trimModelNumber)
        return vid == AMZN_NVME_VID &amp;&amp; mn == AMZN_NVME_EBS_MN
}</span>

func (ns *AwsNitroNVMeService) isInstanceStoreVolume(nir *NVMeIoctlResult) bool <span class="cov8" title="1">{
        vid := nir.IdCtrl.Vid
        mn := strings.TrimRightFunc(string(nir.IdCtrl.Mn[:]), ns.trimModelNumber)
        return vid == AMZN_NVME_VID &amp;&amp; mn == AMZN_NVME_INS_MN
}</span>

func (ns *AwsNitroNVMeService) getBlockDeviceMapping(nir *NVMeIoctlResult) (string, error) <span class="cov8" title="1">{
        var bdm string
        if ns.isEBSVolume(nir) </span><span class="cov8" title="1">{
                bdm = strings.TrimRightFunc(string(nir.IdCtrl.Vs.Bdev[:]), ns.trimBlockDevice)
        }</span>
        <span class="cov8" title="1">if ns.isInstanceStoreVolume(nir) </span><span class="cov8" title="1">{
                // Vendor Specfic (vs)
                vs := strings.TrimRightFunc(string(nir.IdCtrl.Vs.Bdev[:]), ns.trimBlockDevice)
                // Regex Block device Mapping
                rebdm := regexp.MustCompile(`^ephemeral[0-9]:(sd[a-z]|none)`)
                // Match Block Device Mapping
                mbdm := rebdm.FindStringSubmatch(vs)
                if len(mbdm) != 2 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("üî¥ %s: Instance-store vendor specific metadata did not match pattern . Pattern=%s, Actual=%s", nir.Name, rebdm.String(), vs)
                }</span>
                <span class="cov8" title="1">if mbdm[1] == "none" </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("üî¥ %s: Must provide a device name to the Instance Store NVMe block device mapping", nir.Name)
                }</span>
                <span class="cov8" title="1">bdm = mbdm[1]</span>
        }
        <span class="cov8" title="1">if len(bdm) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("üî¥ %s is not an AWS-managed NVME device", nir.Name)
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(bdm, "/dev/") </span><span class="cov8" title="1">{
                bdm = "/dev/" + bdm
        }</span>
        <span class="cov8" title="1">return bdm, nil</span>
}

func (ns *AwsNitroNVMeService) trimModelNumber(r rune) bool <span class="cov8" title="1">{
        // Explanation:
        //         - Both the AWS EC2 and EBS team use the 0x20 (space) byte to pad out the Model Number
        return r == 0x20
}</span>

func (ns *AwsNitroNVMeService) trimBlockDevice(r rune) bool <span class="cov8" title="1">{
        // Explanation:
        //         - The AWS EC2 team uses the 0x00 (null) byte to pad out the Vendor Specific allocation
        //        - The AWS EBS team uses the 0x20 (space) byte to pad out the Vendor Specific allocation
        //        - It is frustrating that the padding character is not standardised, but we can
        //          work around this by checking for both bytes when trimming the Vendor Specific allocation
        // Examples:
        //         nd.IdCtrl.Vs.Bdev[:] ("Amazon EC2 NVMe Instance Storage")
        //                   0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
        // 0000: 65 70 68 65 6d 65 72 61 6c 30 3a 73 64 68 00 00 "ephemeral0:sdh.."
        // 0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "................"
        //        nd.IdCtrl.Vs.Bdev[:] (Amazon Elastic Block Store)
        //        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
        // 0000: 2f 64 65 76 2f 73 64 63 20 20 20 20 20 20 20 20 "/dev/sdc........"
        // 0010: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 "................"
        return r == 0x00 || r == 0x20
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "fmt"
        "os/user"
        "strconv"

        "github.com/reecetech/ebs-bootstrap/internal/model"
)

type OwnerService interface {
        GetUser(usr string) (*model.User, error)
        GetGroup(grp string) (*model.Group, error)
}

type UnixOwnerService struct{}

func NewUnixOwnerService() *UnixOwnerService <span class="cov8" title="1">{
        return &amp;UnixOwnerService{}
}</span>

func (uos *UnixOwnerService) GetUser(usr string) (*model.User, error) <span class="cov8" title="1">{
        var u *user.User
        if _, err := strconv.Atoi(usr); err != nil </span><span class="cov8" title="1">{
                // If not a valid integer, try to look up by username
                u, err = user.Lookup(usr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("üî¥ User (name=%s) does not exist", usr)
                }</span>
        } else<span class="cov8" title="1"> {
                u, err = user.LookupId(usr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("üî¥ User (id=%s) does not exist", usr)
                }</span>
        }
        // We realistically can expect that u.Uid will always be a able
        // to be cast into an unsigned 32-bit integer. Error handling would be dead code
        <span class="cov8" title="1">uid, _ := strconv.ParseUint(u.Uid, 10, 32)
        return &amp;model.User{Name: u.Username, Id: model.UserId(uid)}, nil</span>
}

func (uos *UnixOwnerService) GetGroup(grp string) (*model.Group, error) <span class="cov8" title="1">{
        var g *user.Group
        if _, err := strconv.Atoi(grp); err != nil </span><span class="cov8" title="1">{
                // If not a valid integer, try to look up by group name
                g, err = user.LookupGroup(grp)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("üî¥ Group (name=%s) does not exist", grp)
                }</span>
        } else<span class="cov8" title="1"> {
                g, err = user.LookupGroupId(grp)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("üî¥ Group (id=%s) does not exist", grp)
                }</span>
        }
        // We realistically can expect that g.Gid will always be a able
        // to be cast into an unsigned 32-bit integer. Error handling would be dead code
        <span class="cov8" title="1">gid, _ := strconv.ParseUint(g.Gid, 10, 32)
        return &amp;model.Group{Name: g.Name, Id: model.GroupId(gid)}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
